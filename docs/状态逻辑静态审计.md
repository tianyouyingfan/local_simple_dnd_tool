# 状态逻辑静态审计（代码层面）

本清单来自对 `battle/ui/state/conditions` 相关模块的“写入点”梳理，目标是找出可能绕开数据契约或导致状态不一致的路径。

## 关键写入点分布

- 回合推进与递减：`battle-core.nextTurn()`、`decrementParticipantStatuses()`、`decrementActionCooldowns()`
- HP 变更：`hp-status.applyHPDelta()`、`action-execution.runAction()`（attack / save 两条分支）
- 状态增删：`hp-status.applyStatus()`、`hp-status.removeStatus()`、`action-execution.runAction()`（onHitStatus）
- 持久化与迁移：`main.js` 的 deep watch + 初始化恢复

## 高风险差异/疑点（建议优先验证）

### 1) 自动扣血路径不一致（可能绕过 tempHp 与怪物归零提示）

- attack：直接 `t.hpCurrent = clamp(t.hpCurrent - totalFinalDamage, ...)`
- save：走 `applyHPDelta(target, -final)`

若目标存在 `tempHp`，attack 分支将直接扣 `hpCurrent`；且不会设置 `isDefeated` 与 toast 提示。

### 2) 回合推进的“递减时机”可能 off-by-one

`nextTurn()` 的注释语义是“处理当前行动者回合结束逻辑后再移动”，但目前递减发生在“移动后的 currentActor”上，需要对照期望行为验证。

### 3) 状态自然过期未触发副作用（力竭 HP 上限回退风险）

`decrementParticipantStatuses()` 通过 `rounds-1` 过滤移除状态，但不会像 `removeStatus()` 那样对“移除力竭”触发 `applyExhaustionHpCap()` 回退。

### 4) 力竭等级升级路径（可能无法从 3 升到 4/5/6）

力竭实例的 identity 按 key 去重；当前 `applyStatus()` 遇到已存在力竭时会直接拒绝新增，导致“升级等级”必须通过删除再添加（若 UI 未提供该路径，表现为无法升级）。

### 5) 旧存档迁移对 baseMaxHp 的可逆性

初始化迁移逻辑为 `baseMaxHp == null -> baseMaxHp = hpMax`。若旧存档已因力竭 4+ 将 `hpMax` 减半保存，则 `baseMaxHp` 会被写成减半后的值，后续无法恢复原上限。

