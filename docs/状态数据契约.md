# 状态数据契约（运行时不变量）

本文描述当前代码运行时假设的数据形态，用于排查“状态/回合/HP/持久化”相关的隐蔽 Bug。

## battle（全局战斗状态）

- `battle.participants`: Array\<Participant\>
- `battle.currentIndex`: number（0-based，指向当前行动者）
- `battle.round`: number（\>= 1）
- `battle.dragIndex`: number | null

## Participant（参战单位）

- `uid`: string（全局唯一，作为主键）
- `type`: `'pc' | 'monster'`
- `name`: string
- `ac`: number
- `baseMaxHp`: number（力竭 4+ 的 HP 上限回退基准）
- `hpMax`: number（当前最大 HP，可能被力竭 4+ 影响）
- `hpCurrent`: number（0..hpMax）
- `tempHp`: number（可选，\>=0；扣血应先消耗该值）
- `isDefeated`: boolean（可选；怪物 hp 归零后用于提示并在回合结束移除）
- `justJoined`: boolean（可选；先攻已开始时中途加入，用于跳过当回合）
- `statuses`: Array\<StatusInstance\>（必须为数组）
- `actions`: Array\<ActionInstance\>（必须为数组；每个 action 需包含 `cooldown` 字段）

## StatusInstance（状态实例，必须是规范形态）

状态必须经过 `normalizeStatusInstance()` 归一化后再存入 participant：

- `id`: string（唯一，用于 UI 操作与持久化）
- `key`: string | null（优先使用 conditions 的 condition key）
- `name`: string（用于展示与回填；可带中英组合）
- `icon`: string
- `rounds`: number（\>= 1；回合推进递减至 0 后移除）
- `sourceUid`: string | null（仅部分状态使用，尤其是需要“来源”的可叠加状态）
- `meta`: object（扩展字段；力竭使用 `meta.level`）

语义去重以 `getStatusIdentity()` 为准：

- 大多数状态：按 `key` 去重
- 少数可按来源叠加：按 `key:sourceUid` 去重

## ActionInstance（动作实例）

战斗内单位的 `actions[]` 默认来自实体动作，并额外要求：

- `cooldown`: number（\>= 0；每回合递减）
- `recharge`: number（\>= 0；使用后写入到对应 `cooldown`）

## 持久化与恢复的关键假设

- localStorage 中的 `dnd-battle-state` 会深度序列化整个 `battle`；恢复时会 `Object.assign(battle, parsed)`。
- 恢复后必须保证：
  - `participants[].statuses` 仍为数组，并重新 normalize
  - 旧存档缺少的字段（例如 `baseMaxHp`）会被补齐

